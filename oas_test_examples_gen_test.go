// Code generated by ogen, DO NOT EDIT.

package openshock

import (
	"github.com/go-faster/jx"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestAccountSignUpV2Conflict_EncodeDecode(t *testing.T) {
	var typ AccountSignUpV2Conflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AccountSignUpV2Conflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAccountSignUpV2Forbidden_EncodeDecode(t *testing.T) {
	var typ AccountSignUpV2Forbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AccountSignUpV2Forbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminOnlineDeviceResponse_EncodeDecode(t *testing.T) {
	var typ AdminOnlineDeviceResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminOnlineDeviceResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAdminOnlineDeviceResponseIEnumerableBaseResponse_EncodeDecode(t *testing.T) {
	var typ AdminOnlineDeviceResponseIEnumerableBaseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminOnlineDeviceResponseIEnumerableBaseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBooleanNullableBaseResponse_EncodeDecode(t *testing.T) {
	var typ BooleanNullableBaseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BooleanNullableBaseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestControl_EncodeDecode(t *testing.T) {
	var typ Control
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Control
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestControlLogSenderLight_EncodeDecode(t *testing.T) {
	var typ ControlLogSenderLight
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ControlLogSenderLight
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestControlRequest_EncodeDecode(t *testing.T) {
	var typ ControlRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ControlRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestControlType_EncodeDecode(t *testing.T) {
	var typ ControlType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ControlType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateShareCode_EncodeDecode(t *testing.T) {
	var typ CreateShareCode
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateShareCode
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateTokenRequest_EncodeDecode(t *testing.T) {
	var typ CreateTokenRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateTokenRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeviceEdit_EncodeDecode(t *testing.T) {
	var typ DeviceEdit
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeviceEdit
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeviceSelfResponse_EncodeDecode(t *testing.T) {
	var typ DeviceSelfResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeviceSelfResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeviceSelfResponseBaseResponse_EncodeDecode(t *testing.T) {
	var typ DeviceSelfResponseBaseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeviceSelfResponseBaseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDevicesGetLiveControlGatewayInfoNotFound_EncodeDecode(t *testing.T) {
	var typ DevicesGetLiveControlGatewayInfoNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DevicesGetLiveControlGatewayInfoNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDevicesGetLiveControlGatewayInfoPreconditionFailed_EncodeDecode(t *testing.T) {
	var typ DevicesGetLiveControlGatewayInfoPreconditionFailed
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DevicesGetLiveControlGatewayInfoPreconditionFailed
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEditTokenRequest_EncodeDecode(t *testing.T) {
	var typ EditTokenRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EditTokenRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGenericIni_EncodeDecode(t *testing.T) {
	var typ GenericIni
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GenericIni
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGuidBaseResponse_EncodeDecode(t *testing.T) {
	var typ GuidBaseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GuidBaseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLcgNodeResponse_EncodeDecode(t *testing.T) {
	var typ LcgNodeResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LcgNodeResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLcgNodeResponseBaseResponse_EncodeDecode(t *testing.T) {
	var typ LcgNodeResponseBaseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LcgNodeResponseBaseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLcgResponse_EncodeDecode(t *testing.T) {
	var typ LcgResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LcgResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLcgResponseBaseResponse_EncodeDecode(t *testing.T) {
	var typ LcgResponseBaseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LcgResponseBaseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLogEntry_EncodeDecode(t *testing.T) {
	var typ LogEntry
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LogEntry
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLogEntryIEnumerableBaseResponse_EncodeDecode(t *testing.T) {
	var typ LogEntryIEnumerableBaseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LogEntryIEnumerableBaseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLogin_EncodeDecode(t *testing.T) {
	var typ Login
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Login
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLoginV2_EncodeDecode(t *testing.T) {
	var typ LoginV2
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LoginV2
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMinimalShocker_EncodeDecode(t *testing.T) {
	var typ MinimalShocker
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MinimalShocker
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewShocker_EncodeDecode(t *testing.T) {
	var typ NewShocker
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewShocker
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestObjectBaseResponse_EncodeDecode(t *testing.T) {
	var typ ObjectBaseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ObjectBaseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOpenShockProblem_EncodeDecode(t *testing.T) {
	var typ OpenShockProblem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OpenShockProblem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOpenShockProblemAdditional_EncodeDecode(t *testing.T) {
	var typ OpenShockProblemAdditional
	typ = make(OpenShockProblemAdditional)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OpenShockProblemAdditional
	typ2 = make(OpenShockProblemAdditional)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOtaItem_EncodeDecode(t *testing.T) {
	var typ OtaItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OtaItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOtaItemIReadOnlyCollectionBaseResponse_EncodeDecode(t *testing.T) {
	var typ OtaItemIReadOnlyCollectionBaseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OtaItemIReadOnlyCollectionBaseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOtaUpdateStatus_EncodeDecode(t *testing.T) {
	var typ OtaUpdateStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OtaUpdateStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOwnerShockerResponse_EncodeDecode(t *testing.T) {
	var typ OwnerShockerResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OwnerShockerResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOwnerShockerResponseIEnumerableIEnumerableBaseResponse_EncodeDecode(t *testing.T) {
	var typ OwnerShockerResponseIEnumerableIEnumerableBaseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OwnerShockerResponseIEnumerableIEnumerableBaseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPasswordResetProcessData_EncodeDecode(t *testing.T) {
	var typ PasswordResetProcessData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PasswordResetProcessData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPauseReasonBaseResponse_EncodeDecode(t *testing.T) {
	var typ PauseReasonBaseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PauseReasonBaseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPauseRequest_EncodeDecode(t *testing.T) {
	var typ PauseRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PauseRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPermissionType_EncodeDecode(t *testing.T) {
	var typ PermissionType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PermissionType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPublicShareLinkResponse_EncodeDecode(t *testing.T) {
	var typ PublicShareLinkResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PublicShareLinkResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPublicShareLinkResponseBaseResponse_EncodeDecode(t *testing.T) {
	var typ PublicShareLinkResponseBaseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PublicShareLinkResponseBaseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRankType_EncodeDecode(t *testing.T) {
	var typ RankType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RankType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResetRequest_EncodeDecode(t *testing.T) {
	var typ ResetRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResetRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResponseDevice_EncodeDecode(t *testing.T) {
	var typ ResponseDevice
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResponseDevice
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResponseDeviceIEnumerableBaseResponse_EncodeDecode(t *testing.T) {
	var typ ResponseDeviceIEnumerableBaseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResponseDeviceIEnumerableBaseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResponseDeviceWithShockers_EncodeDecode(t *testing.T) {
	var typ ResponseDeviceWithShockers
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResponseDeviceWithShockers
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResponseDeviceWithShockersIEnumerableBaseResponse_EncodeDecode(t *testing.T) {
	var typ ResponseDeviceWithShockersIEnumerableBaseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResponseDeviceWithShockersIEnumerableBaseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResponseDeviceWithToken_EncodeDecode(t *testing.T) {
	var typ ResponseDeviceWithToken
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResponseDeviceWithToken
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResponseDeviceWithTokenBaseResponse_EncodeDecode(t *testing.T) {
	var typ ResponseDeviceWithTokenBaseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResponseDeviceWithTokenBaseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRootResponse_EncodeDecode(t *testing.T) {
	var typ RootResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RootResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRootResponseBaseResponse_EncodeDecode(t *testing.T) {
	var typ RootResponseBaseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RootResponseBaseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSelfResponse_EncodeDecode(t *testing.T) {
	var typ SelfResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SelfResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSelfResponseBaseResponse_EncodeDecode(t *testing.T) {
	var typ SelfResponseBaseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SelfResponseBaseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestShareCodeInfo_EncodeDecode(t *testing.T) {
	var typ ShareCodeInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ShareCodeInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestShareCodeInfoIEnumerableBaseResponse_EncodeDecode(t *testing.T) {
	var typ ShareCodeInfoIEnumerableBaseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ShareCodeInfoIEnumerableBaseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestShareInfo_EncodeDecode(t *testing.T) {
	var typ ShareInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ShareInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestShareInfoIEnumerableBaseResponse_EncodeDecode(t *testing.T) {
	var typ ShareInfoIEnumerableBaseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ShareInfoIEnumerableBaseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestShareLinkCreate_EncodeDecode(t *testing.T) {
	var typ ShareLinkCreate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ShareLinkCreate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestShareLinkDevice_EncodeDecode(t *testing.T) {
	var typ ShareLinkDevice
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ShareLinkDevice
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestShareLinkEditShocker_EncodeDecode(t *testing.T) {
	var typ ShareLinkEditShocker
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ShareLinkEditShocker
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestShareLinkResponse_EncodeDecode(t *testing.T) {
	var typ ShareLinkResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ShareLinkResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestShareLinkResponseBaseResponse_EncodeDecode(t *testing.T) {
	var typ ShareLinkResponseBaseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ShareLinkResponseBaseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestShareLinkResponseIEnumerableBaseResponse_EncodeDecode(t *testing.T) {
	var typ ShareLinkResponseIEnumerableBaseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ShareLinkResponseIEnumerableBaseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestShareLinkShocker_EncodeDecode(t *testing.T) {
	var typ ShareLinkShocker
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ShareLinkShocker
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestShareLinksAddShockerConflict_EncodeDecode(t *testing.T) {
	var typ ShareLinksAddShockerConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ShareLinksAddShockerConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestShareLinksAddShockerNotFound_EncodeDecode(t *testing.T) {
	var typ ShareLinksAddShockerNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ShareLinksAddShockerNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSharedDevice_EncodeDecode(t *testing.T) {
	var typ SharedDevice
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SharedDevice
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSharedShocker_EncodeDecode(t *testing.T) {
	var typ SharedShocker
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SharedShocker
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSharesLinkShareCodeBadRequest_EncodeDecode(t *testing.T) {
	var typ SharesLinkShareCodeBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SharesLinkShareCodeBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSharesLinkShareCodeNotFound_EncodeDecode(t *testing.T) {
	var typ SharesLinkShareCodeNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SharesLinkShareCodeNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestShockerLimits_EncodeDecode(t *testing.T) {
	var typ ShockerLimits
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ShockerLimits
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestShockerModelType_EncodeDecode(t *testing.T) {
	var typ ShockerModelType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ShockerModelType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestShockerPermissions_EncodeDecode(t *testing.T) {
	var typ ShockerPermissions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ShockerPermissions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestShockerRegisterShockerBadRequest_EncodeDecode(t *testing.T) {
	var typ ShockerRegisterShockerBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ShockerRegisterShockerBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestShockerRegisterShockerNotFound_EncodeDecode(t *testing.T) {
	var typ ShockerRegisterShockerNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ShockerRegisterShockerNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestShockerResponse_EncodeDecode(t *testing.T) {
	var typ ShockerResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ShockerResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestShockerResponseIEnumerableBaseResponse_EncodeDecode(t *testing.T) {
	var typ ShockerResponseIEnumerableBaseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ShockerResponseIEnumerableBaseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestShockerSendControlDEPRECATEDForbidden_EncodeDecode(t *testing.T) {
	var typ ShockerSendControlDEPRECATEDForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ShockerSendControlDEPRECATEDForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestShockerSendControlDEPRECATEDNotFound_EncodeDecode(t *testing.T) {
	var typ ShockerSendControlDEPRECATEDNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ShockerSendControlDEPRECATEDNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestShockerSendControlDEPRECATEDPreconditionFailed_EncodeDecode(t *testing.T) {
	var typ ShockerSendControlDEPRECATEDPreconditionFailed
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ShockerSendControlDEPRECATEDPreconditionFailed
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestShockerSendControlForbidden_EncodeDecode(t *testing.T) {
	var typ ShockerSendControlForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ShockerSendControlForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestShockerSendControlNotFound_EncodeDecode(t *testing.T) {
	var typ ShockerSendControlNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ShockerSendControlNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestShockerSendControlPreconditionFailed_EncodeDecode(t *testing.T) {
	var typ ShockerSendControlPreconditionFailed
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ShockerSendControlPreconditionFailed
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestShockerWithDevice_EncodeDecode(t *testing.T) {
	var typ ShockerWithDevice
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ShockerWithDevice
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestShockerWithDeviceBaseResponse_EncodeDecode(t *testing.T) {
	var typ ShockerWithDeviceBaseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ShockerWithDeviceBaseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSignUp_EncodeDecode(t *testing.T) {
	var typ SignUp
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SignUp
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSignUpV2_EncodeDecode(t *testing.T) {
	var typ SignUpV2
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SignUpV2
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestStatsResponse_EncodeDecode(t *testing.T) {
	var typ StatsResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 StatsResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestStatsResponseBaseResponse_EncodeDecode(t *testing.T) {
	var typ StatsResponseBaseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 StatsResponseBaseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestStringBaseResponse_EncodeDecode(t *testing.T) {
	var typ StringBaseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 StringBaseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTokenResponse_EncodeDecode(t *testing.T) {
	var typ TokenResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TokenResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTokenResponseBaseResponse_EncodeDecode(t *testing.T) {
	var typ TokenResponseBaseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TokenResponseBaseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTokenResponseIEnumerableBaseResponse_EncodeDecode(t *testing.T) {
	var typ TokenResponseIEnumerableBaseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TokenResponseIEnumerableBaseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
