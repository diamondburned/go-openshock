// Code generated by ogen, DO NOT EDIT.

package openshock

import (
	"context"
	"fmt"
	"net/url"
	"strings"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// AccountLogin invokes Account_Login operation.
	//
	// Authenticate a user.
	//
	// POST /1/account/login
	AccountLogin(ctx context.Context, request OptLogin) (AccountLoginRes, error)
	// AccountLoginV2 invokes Account_LoginV2 operation.
	//
	// Authenticate a user.
	//
	// POST /2/account/login
	AccountLoginV2(ctx context.Context, request OptLoginV2) (AccountLoginV2Res, error)
	// AccountPasswordResetCheckValid invokes Account_PasswordResetCheckValid operation.
	//
	// Check if a password reset is in progress.
	//
	// HEAD /1/account/recover/{passwordResetId}/{secret}
	AccountPasswordResetCheckValid(ctx context.Context, params AccountPasswordResetCheckValidParams) (AccountPasswordResetCheckValidRes, error)
	// AccountPasswordResetComplete invokes Account_PasswordResetComplete operation.
	//
	// Complete a password reset process.
	//
	// POST /1/account/recover/{passwordResetId}/{secret}
	AccountPasswordResetComplete(ctx context.Context, request OptPasswordResetProcessData, params AccountPasswordResetCompleteParams) (AccountPasswordResetCompleteRes, error)
	// AccountPasswordResetInitiate invokes Account_PasswordResetInitiate operation.
	//
	// Initiate a password reset.
	//
	// POST /1/account/reset
	AccountPasswordResetInitiate(ctx context.Context, request OptResetRequest) (*ObjectBaseResponse, error)
	// AccountSignUp invokes Account_SignUp operation.
	//
	// Signs up a new user.
	//
	// POST /1/account/signup
	AccountSignUp(ctx context.Context, request OptSignUp) (AccountSignUpRes, error)
	// AccountSignUpV2 invokes Account_SignUpV2 operation.
	//
	// Signs up a new user.
	//
	// POST /2/account/signup
	AccountSignUpV2(ctx context.Context, request OptSignUpV2) (AccountSignUpV2Res, error)
	// AdminGetOnlineDevices invokes Admin_GetOnlineDevices operation.
	//
	// Gets all online devices.
	//
	// GET /1/admin/monitoring/onlineDevices
	AdminGetOnlineDevices(ctx context.Context) (AdminGetOnlineDevicesRes, error)
	// DeviceGetLiveControlGateway invokes Device_GetLiveControlGateway operation.
	//
	// Gets the best suited LCG node for the client.
	//
	// GET /1/device/assignLCG
	DeviceGetLiveControlGateway(ctx context.Context) (DeviceGetLiveControlGatewayRes, error)
	// DeviceGetSelf invokes Device_GetSelf operation.
	//
	// Gets information about the authenticated device.
	//
	// GET /1/device/self
	DeviceGetSelf(ctx context.Context) (*DeviceSelfResponseBaseResponse, error)
	// DevicePair invokes Device_Pair operation.
	//
	// Pair a device with a pair code.
	//
	// GET /1/device/pair/{pairCode}
	DevicePair(ctx context.Context, params DevicePairParams) (DevicePairRes, error)
	// DevicePairDEPRECATED invokes Device_Pair_DEPRECATED operation.
	//
	// Pair a device with a pair code.
	//
	// GET /1/pair/{pairCode}
	DevicePairDEPRECATED(ctx context.Context, params DevicePairDEPRECATEDParams) (DevicePairDEPRECATEDRes, error)
	// DevicesCreateDevice invokes Devices_CreateDevice operation.
	//
	// Create a new device for the current user.
	//
	// POST /1/devices
	DevicesCreateDevice(ctx context.Context) (*GuidBaseResponse, error)
	// DevicesEditDevice invokes Devices_EditDevice operation.
	//
	// Edit a device.
	//
	// PATCH /1/devices/{deviceId}
	DevicesEditDevice(ctx context.Context, request OptDeviceEdit, params DevicesEditDeviceParams) (DevicesEditDeviceRes, error)
	// DevicesGetDeviceById invokes Devices_GetDeviceById operation.
	//
	// Get a device by its id.
	//
	// GET /1/devices/{deviceId}
	DevicesGetDeviceById(ctx context.Context, params DevicesGetDeviceByIdParams) (DevicesGetDeviceByIdRes, error)
	// DevicesGetLiveControlGatewayInfo invokes Devices_GetLiveControlGatewayInfo operation.
	//
	// Get LCG info for a device if it is online and connected to a LCG node.
	//
	// GET /1/devices/{deviceId}/lcg
	DevicesGetLiveControlGatewayInfo(ctx context.Context, params DevicesGetLiveControlGatewayInfoParams) (DevicesGetLiveControlGatewayInfoRes, error)
	// DevicesGetOtaUpdateHistory invokes Devices_GetOtaUpdateHistory operation.
	//
	// Gets the OTA update history for a device.
	//
	// GET /1/devices/{deviceId}/ota
	DevicesGetOtaUpdateHistory(ctx context.Context, params DevicesGetOtaUpdateHistoryParams) (DevicesGetOtaUpdateHistoryRes, error)
	// DevicesGetPairCode invokes Devices_GetPairCode operation.
	//
	// Get a pair code for a device.
	//
	// GET /1/devices/{deviceId}/pair
	DevicesGetPairCode(ctx context.Context, params DevicesGetPairCodeParams) (DevicesGetPairCodeRes, error)
	// DevicesGetShockers invokes Devices_GetShockers operation.
	//
	// Get all shockers for a device.
	//
	// GET /1/devices/{deviceId}/shockers
	DevicesGetShockers(ctx context.Context, params DevicesGetShockersParams) (DevicesGetShockersRes, error)
	// DevicesListDevices invokes Devices_ListDevices operation.
	//
	// Get all devices for the current user.
	//
	// GET /1/devices
	DevicesListDevices(ctx context.Context) (*ResponseDeviceIEnumerableBaseResponse, error)
	// DevicesRegenerateDeviceToken invokes Devices_RegenerateDeviceToken operation.
	//
	// Regenerate a device token.
	//
	// PUT /1/devices/{deviceId}
	DevicesRegenerateDeviceToken(ctx context.Context, params DevicesRegenerateDeviceTokenParams) (DevicesRegenerateDeviceTokenRes, error)
	// DevicesRemoveDevice invokes Devices_RemoveDevice operation.
	//
	// Remove a device from current user's account.
	//
	// DELETE /1/devices/{deviceId}
	DevicesRemoveDevice(ctx context.Context, params DevicesRemoveDeviceParams) (DevicesRemoveDeviceRes, error)
	// PublicGetOnlineDevicesStatistics invokes Public_GetOnlineDevicesStatistics operation.
	//
	// Gets online devices statistics.
	//
	// GET /1/public/stats
	PublicGetOnlineDevicesStatistics(ctx context.Context) (*StatsResponseBaseResponse, error)
	// PublicGetShareLink invokes Public_GetShareLink operation.
	//
	// Gets information about a public share link.
	//
	// GET /1/public/shares/links/{shareLinkId}
	PublicGetShareLink(ctx context.Context, params PublicGetShareLinkParams) (PublicGetShareLinkRes, error)
	// ShareLinksAddShocker invokes ShareLinks_AddShocker operation.
	//
	// Add a shocker to a share link.
	//
	// POST /1/shares/links/{shareLinkId}/{shockerId}
	ShareLinksAddShocker(ctx context.Context, params ShareLinksAddShockerParams) (ShareLinksAddShockerRes, error)
	// ShareLinksCreateShareLink invokes ShareLinks_CreateShareLink operation.
	//
	// Create a new share link.
	//
	// POST /1/shares/links
	ShareLinksCreateShareLink(ctx context.Context, request OptShareLinkCreate) (*GuidBaseResponse, error)
	// ShareLinksDeleteShareLink invokes ShareLinks_DeleteShareLink operation.
	//
	// Deletes a share link.
	//
	// DELETE /1/shares/links/{shareLinkId}
	ShareLinksDeleteShareLink(ctx context.Context, params ShareLinksDeleteShareLinkParams) (ShareLinksDeleteShareLinkRes, error)
	// ShareLinksEditShocker invokes ShareLinks_EditShocker operation.
	//
	// Edit a shocker in a share link.
	//
	// PATCH /1/shares/links/{shareLinkId}/{shockerId}
	ShareLinksEditShocker(ctx context.Context, request OptShareLinkEditShocker, params ShareLinksEditShockerParams) (ShareLinksEditShockerRes, error)
	// ShareLinksList invokes ShareLinks_List operation.
	//
	// Get all share links for the current user.
	//
	// GET /1/shares/links
	ShareLinksList(ctx context.Context) (*ShareLinkResponseIEnumerableBaseResponse, error)
	// ShareLinksPauseShocker invokes ShareLinks_PauseShocker operation.
	//
	// Pause a shocker in a share link.
	//
	// POST /1/shares/links/{shareLinkId}/{shockerId}/pause
	ShareLinksPauseShocker(ctx context.Context, request OptPauseRequest, params ShareLinksPauseShockerParams) (ShareLinksPauseShockerRes, error)
	// ShareLinksRemoveShocker invokes ShareLinks_RemoveShocker operation.
	//
	// Remove a shocker from a share link.
	//
	// DELETE /1/shares/links/{shareLinkId}/{shockerId}
	ShareLinksRemoveShocker(ctx context.Context, params ShareLinksRemoveShockerParams) (ShareLinksRemoveShockerRes, error)
	// SharesDeleteShareCode invokes Shares_DeleteShareCode operation.
	//
	// Delete a share code.
	//
	// DELETE /1/shares/code/{shareCodeId}
	SharesDeleteShareCode(ctx context.Context, params SharesDeleteShareCodeParams) (SharesDeleteShareCodeRes, error)
	// SharesLinkShareCode invokes Shares_LinkShareCode operation.
	//
	// Link a share code to your account.
	//
	// POST /1/shares/code/{shareCodeId}
	SharesLinkShareCode(ctx context.Context, params SharesLinkShareCodeParams) (SharesLinkShareCodeRes, error)
	// ShockerEditShocker invokes Shocker_EditShocker operation.
	//
	// Edit a shocker.
	//
	// PATCH /1/shockers/{shockerId}
	ShockerEditShocker(ctx context.Context, request OptNewShocker, params ShockerEditShockerParams) (ShockerEditShockerRes, error)
	// ShockerGetShockerById invokes Shocker_GetShockerById operation.
	//
	// Get information about a shocker.
	//
	// GET /1/shockers/{shockerId}
	ShockerGetShockerById(ctx context.Context, params ShockerGetShockerByIdParams) (ShockerGetShockerByIdRes, error)
	// ShockerGetShockerLogs invokes Shocker_GetShockerLogs operation.
	//
	// Get the logs for a shocker.
	//
	// GET /1/shockers/{shockerId}/logs
	ShockerGetShockerLogs(ctx context.Context, params ShockerGetShockerLogsParams) (ShockerGetShockerLogsRes, error)
	// ShockerGetShockerShares invokes Shocker_GetShockerShares operation.
	//
	// Get all shares for a shocker.
	//
	// GET /1/shockers/{shockerId}/shares
	ShockerGetShockerShares(ctx context.Context, params ShockerGetShockerSharesParams) (ShockerGetShockerSharesRes, error)
	// ShockerListSharedShockers invokes Shocker_ListSharedShockers operation.
	//
	// List all shockers shared with the authenticated user.
	//
	// GET /1/shockers/shared
	ShockerListSharedShockers(ctx context.Context) (*OwnerShockerResponseIEnumerableIEnumerableBaseResponse, error)
	// ShockerListShockers invokes Shocker_ListShockers operation.
	//
	// List all shockers belonging to the authenticated user.
	//
	// GET /1/shockers/own
	ShockerListShockers(ctx context.Context) (*ResponseDeviceWithShockersIEnumerableBaseResponse, error)
	// ShockerPauseShocker invokes Shocker_PauseShocker operation.
	//
	// Pause or unpause a shocker.
	//
	// POST /1/shockers/{shockerId}/pause
	ShockerPauseShocker(ctx context.Context, request OptPauseRequest, params ShockerPauseShockerParams) (ShockerPauseShockerRes, error)
	// ShockerRegisterShocker invokes Shocker_RegisterShocker operation.
	//
	// Register a shocker.
	//
	// POST /1/shockers
	ShockerRegisterShocker(ctx context.Context, request OptNewShocker) (ShockerRegisterShockerRes, error)
	// ShockerRemoveShocker invokes Shocker_RemoveShocker operation.
	//
	// Remove a shocker.
	//
	// DELETE /1/shockers/{shockerId}
	ShockerRemoveShocker(ctx context.Context, params ShockerRemoveShockerParams) (ShockerRemoveShockerRes, error)
	// ShockerSendControl invokes Shocker_SendControl operation.
	//
	// Send a control message to shockers.
	//
	// POST /2/shockers/control
	ShockerSendControl(ctx context.Context, request OptControlRequest) (ShockerSendControlRes, error)
	// ShockerSendControlDEPRECATED invokes Shocker_SendControl_DEPRECATED operation.
	//
	// Send a control message to shockers (Deprecated in favor of the /2/shockers/control endpoint).
	//
	// POST /1/shockers/control
	ShockerSendControlDEPRECATED(ctx context.Context, request []Control) (ShockerSendControlDEPRECATEDRes, error)
	// ShockerShockerShareCodeCreate invokes Shocker_ShockerShareCodeCreate operation.
	//
	// Create a share code for a shocker.
	//
	// POST /1/shockers/{shockerId}/shares
	ShockerShockerShareCodeCreate(ctx context.Context, request OptCreateShareCode, params ShockerShockerShareCodeCreateParams) (ShockerShockerShareCodeCreateRes, error)
	// ShockerShockerShareCodeList invokes Shocker_ShockerShareCodeList operation.
	//
	// List all share codes for a shocker.
	//
	// GET /1/shockers/{shockerId}/shareCodes
	ShockerShockerShareCodeList(ctx context.Context, params ShockerShockerShareCodeListParams) (ShockerShockerShareCodeListRes, error)
	// ShockerShockerShareCodePause invokes Shocker_ShockerShareCodePause operation.
	//
	// Pause/Unpause a share code for a shocker.
	//
	// POST /1/shockers/{shockerId}/shares/{sharedWithUserId}/pause
	ShockerShockerShareCodePause(ctx context.Context, request OptPauseRequest, params ShockerShockerShareCodePauseParams) (ShockerShockerShareCodePauseRes, error)
	// ShockerShockerShareCodeRemove invokes Shocker_ShockerShareCodeRemove operation.
	//
	// Remove a share code for a shocker.
	//
	// DELETE /1/shockers/{shockerId}/shares/{sharedWithUserId}
	ShockerShockerShareCodeRemove(ctx context.Context, params ShockerShockerShareCodeRemoveParams) (ShockerShockerShareCodeRemoveRes, error)
	// ShockerShockerShareCodeUpdate invokes Shocker_ShockerShareCodeUpdate operation.
	//
	// Update a share code for a shocker.
	//
	// PATCH /1/shockers/{shockerId}/shares/{sharedWithUserId}
	ShockerShockerShareCodeUpdate(ctx context.Context, request OptCreateShareCode, params ShockerShockerShareCodeUpdateParams) (ShockerShockerShareCodeUpdateRes, error)
	// TokensCreateToken invokes Tokens_CreateToken operation.
	//
	// Create a new token.
	//
	// POST /1/tokens
	TokensCreateToken(ctx context.Context, request OptCreateTokenRequest) (*StringBaseResponse, error)
	// TokensDeleteToken invokes Tokens_DeleteToken operation.
	//
	// Revoke a token from the current user.
	//
	// DELETE /1/tokens/{tokenId}
	TokensDeleteToken(ctx context.Context, params TokensDeleteTokenParams) (TokensDeleteTokenRes, error)
	// TokensEditToken invokes Tokens_EditToken operation.
	//
	// Edit a token.
	//
	// PATCH /1/tokens/{tokenId}
	TokensEditToken(ctx context.Context, request OptEditTokenRequest, params TokensEditTokenParams) (TokensEditTokenRes, error)
	// TokensGetTokenById invokes Tokens_GetTokenById operation.
	//
	// Get a token by id.
	//
	// GET /1/tokens/{tokenId}
	TokensGetTokenById(ctx context.Context, params TokensGetTokenByIdParams) (TokensGetTokenByIdRes, error)
	// TokensListTokens invokes Tokens_ListTokens operation.
	//
	// List all tokens for the current user.
	//
	// GET /1/tokens
	TokensListTokens(ctx context.Context) (*TokenResponseIEnumerableBaseResponse, error)
	// UsersGetSelf invokes Users_GetSelf operation.
	//
	// Get the current user's information.
	//
	// GET /1/users/self
	UsersGetSelf(ctx context.Context) (*SelfResponseBaseResponse, error)
	// VersionGetBackendVersion invokes Version_GetBackendVersion operation.
	//
	// Gets the version of the OpenShock backend.
	//
	// GET /1
	VersionGetBackendVersion(ctx context.Context) (*RootResponseBaseResponse, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// AccountLogin invokes Account_Login operation.
//
// Authenticate a user.
//
// POST /1/account/login
func (c *Client) AccountLogin(ctx context.Context, request OptLogin) (AccountLoginRes, error) {
	res, err := c.sendAccountLogin(ctx, request)
	return res, err
}

func (c *Client) sendAccountLogin(ctx context.Context, request OptLogin) (res AccountLoginRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/1/account/login"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAccountLoginRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "AccountLogin", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAccountLoginResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AccountLoginV2 invokes Account_LoginV2 operation.
//
// Authenticate a user.
//
// POST /2/account/login
func (c *Client) AccountLoginV2(ctx context.Context, request OptLoginV2) (AccountLoginV2Res, error) {
	res, err := c.sendAccountLoginV2(ctx, request)
	return res, err
}

func (c *Client) sendAccountLoginV2(ctx context.Context, request OptLoginV2) (res AccountLoginV2Res, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/2/account/login"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAccountLoginV2Request(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "AccountLoginV2", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAccountLoginV2Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AccountPasswordResetCheckValid invokes Account_PasswordResetCheckValid operation.
//
// Check if a password reset is in progress.
//
// HEAD /1/account/recover/{passwordResetId}/{secret}
func (c *Client) AccountPasswordResetCheckValid(ctx context.Context, params AccountPasswordResetCheckValidParams) (AccountPasswordResetCheckValidRes, error) {
	res, err := c.sendAccountPasswordResetCheckValid(ctx, params)
	return res, err
}

func (c *Client) sendAccountPasswordResetCheckValid(ctx context.Context, params AccountPasswordResetCheckValidParams) (res AccountPasswordResetCheckValidRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/1/account/recover/"
	{
		// Encode "passwordResetId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "passwordResetId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.PasswordResetId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "secret" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Secret))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "HEAD", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "AccountPasswordResetCheckValid", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAccountPasswordResetCheckValidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AccountPasswordResetComplete invokes Account_PasswordResetComplete operation.
//
// Complete a password reset process.
//
// POST /1/account/recover/{passwordResetId}/{secret}
func (c *Client) AccountPasswordResetComplete(ctx context.Context, request OptPasswordResetProcessData, params AccountPasswordResetCompleteParams) (AccountPasswordResetCompleteRes, error) {
	res, err := c.sendAccountPasswordResetComplete(ctx, request, params)
	return res, err
}

func (c *Client) sendAccountPasswordResetComplete(ctx context.Context, request OptPasswordResetProcessData, params AccountPasswordResetCompleteParams) (res AccountPasswordResetCompleteRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/1/account/recover/"
	{
		// Encode "passwordResetId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "passwordResetId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.PasswordResetId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "secret" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Secret))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAccountPasswordResetCompleteRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "AccountPasswordResetComplete", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAccountPasswordResetCompleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AccountPasswordResetInitiate invokes Account_PasswordResetInitiate operation.
//
// Initiate a password reset.
//
// POST /1/account/reset
func (c *Client) AccountPasswordResetInitiate(ctx context.Context, request OptResetRequest) (*ObjectBaseResponse, error) {
	res, err := c.sendAccountPasswordResetInitiate(ctx, request)
	return res, err
}

func (c *Client) sendAccountPasswordResetInitiate(ctx context.Context, request OptResetRequest) (res *ObjectBaseResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/1/account/reset"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAccountPasswordResetInitiateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "AccountPasswordResetInitiate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAccountPasswordResetInitiateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AccountSignUp invokes Account_SignUp operation.
//
// Signs up a new user.
//
// POST /1/account/signup
func (c *Client) AccountSignUp(ctx context.Context, request OptSignUp) (AccountSignUpRes, error) {
	res, err := c.sendAccountSignUp(ctx, request)
	return res, err
}

func (c *Client) sendAccountSignUp(ctx context.Context, request OptSignUp) (res AccountSignUpRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/1/account/signup"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAccountSignUpRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "AccountSignUp", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAccountSignUpResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AccountSignUpV2 invokes Account_SignUpV2 operation.
//
// Signs up a new user.
//
// POST /2/account/signup
func (c *Client) AccountSignUpV2(ctx context.Context, request OptSignUpV2) (AccountSignUpV2Res, error) {
	res, err := c.sendAccountSignUpV2(ctx, request)
	return res, err
}

func (c *Client) sendAccountSignUpV2(ctx context.Context, request OptSignUpV2) (res AccountSignUpV2Res, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/2/account/signup"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAccountSignUpV2Request(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "AccountSignUpV2", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAccountSignUpV2Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AdminGetOnlineDevices invokes Admin_GetOnlineDevices operation.
//
// Gets all online devices.
//
// GET /1/admin/monitoring/onlineDevices
func (c *Client) AdminGetOnlineDevices(ctx context.Context) (AdminGetOnlineDevicesRes, error) {
	res, err := c.sendAdminGetOnlineDevices(ctx)
	return res, err
}

func (c *Client) sendAdminGetOnlineDevices(ctx context.Context) (res AdminGetOnlineDevicesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/1/admin/monitoring/onlineDevices"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "AdminGetOnlineDevices", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAdminGetOnlineDevicesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeviceGetLiveControlGateway invokes Device_GetLiveControlGateway operation.
//
// Gets the best suited LCG node for the client.
//
// GET /1/device/assignLCG
func (c *Client) DeviceGetLiveControlGateway(ctx context.Context) (DeviceGetLiveControlGatewayRes, error) {
	res, err := c.sendDeviceGetLiveControlGateway(ctx)
	return res, err
}

func (c *Client) sendDeviceGetLiveControlGateway(ctx context.Context) (res DeviceGetLiveControlGatewayRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/1/device/assignLCG"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "DeviceGetLiveControlGateway", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeviceGetLiveControlGatewayResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeviceGetSelf invokes Device_GetSelf operation.
//
// Gets information about the authenticated device.
//
// GET /1/device/self
func (c *Client) DeviceGetSelf(ctx context.Context) (*DeviceSelfResponseBaseResponse, error) {
	res, err := c.sendDeviceGetSelf(ctx)
	return res, err
}

func (c *Client) sendDeviceGetSelf(ctx context.Context) (res *DeviceSelfResponseBaseResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/1/device/self"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "DeviceGetSelf", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeviceGetSelfResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DevicePair invokes Device_Pair operation.
//
// Pair a device with a pair code.
//
// GET /1/device/pair/{pairCode}
func (c *Client) DevicePair(ctx context.Context, params DevicePairParams) (DevicePairRes, error) {
	res, err := c.sendDevicePair(ctx, params)
	return res, err
}

func (c *Client) sendDevicePair(ctx context.Context, params DevicePairParams) (res DevicePairRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/1/device/pair/"
	{
		// Encode "pairCode" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pairCode",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PairCode))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "DevicePair", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDevicePairResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DevicePairDEPRECATED invokes Device_Pair_DEPRECATED operation.
//
// Pair a device with a pair code.
//
// GET /1/pair/{pairCode}
func (c *Client) DevicePairDEPRECATED(ctx context.Context, params DevicePairDEPRECATEDParams) (DevicePairDEPRECATEDRes, error) {
	res, err := c.sendDevicePairDEPRECATED(ctx, params)
	return res, err
}

func (c *Client) sendDevicePairDEPRECATED(ctx context.Context, params DevicePairDEPRECATEDParams) (res DevicePairDEPRECATEDRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/1/pair/"
	{
		// Encode "pairCode" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pairCode",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PairCode))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "DevicePairDEPRECATED", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDevicePairDEPRECATEDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DevicesCreateDevice invokes Devices_CreateDevice operation.
//
// Create a new device for the current user.
//
// POST /1/devices
func (c *Client) DevicesCreateDevice(ctx context.Context) (*GuidBaseResponse, error) {
	res, err := c.sendDevicesCreateDevice(ctx)
	return res, err
}

func (c *Client) sendDevicesCreateDevice(ctx context.Context) (res *GuidBaseResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/1/devices"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "DevicesCreateDevice", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDevicesCreateDeviceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DevicesEditDevice invokes Devices_EditDevice operation.
//
// Edit a device.
//
// PATCH /1/devices/{deviceId}
func (c *Client) DevicesEditDevice(ctx context.Context, request OptDeviceEdit, params DevicesEditDeviceParams) (DevicesEditDeviceRes, error) {
	res, err := c.sendDevicesEditDevice(ctx, request, params)
	return res, err
}

func (c *Client) sendDevicesEditDevice(ctx context.Context, request OptDeviceEdit, params DevicesEditDeviceParams) (res DevicesEditDeviceRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/1/devices/"
	{
		// Encode "deviceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "deviceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.DeviceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDevicesEditDeviceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "DevicesEditDevice", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDevicesEditDeviceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DevicesGetDeviceById invokes Devices_GetDeviceById operation.
//
// Get a device by its id.
//
// GET /1/devices/{deviceId}
func (c *Client) DevicesGetDeviceById(ctx context.Context, params DevicesGetDeviceByIdParams) (DevicesGetDeviceByIdRes, error) {
	res, err := c.sendDevicesGetDeviceById(ctx, params)
	return res, err
}

func (c *Client) sendDevicesGetDeviceById(ctx context.Context, params DevicesGetDeviceByIdParams) (res DevicesGetDeviceByIdRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/1/devices/"
	{
		// Encode "deviceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "deviceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.DeviceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "DevicesGetDeviceById", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDevicesGetDeviceByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DevicesGetLiveControlGatewayInfo invokes Devices_GetLiveControlGatewayInfo operation.
//
// Get LCG info for a device if it is online and connected to a LCG node.
//
// GET /1/devices/{deviceId}/lcg
func (c *Client) DevicesGetLiveControlGatewayInfo(ctx context.Context, params DevicesGetLiveControlGatewayInfoParams) (DevicesGetLiveControlGatewayInfoRes, error) {
	res, err := c.sendDevicesGetLiveControlGatewayInfo(ctx, params)
	return res, err
}

func (c *Client) sendDevicesGetLiveControlGatewayInfo(ctx context.Context, params DevicesGetLiveControlGatewayInfoParams) (res DevicesGetLiveControlGatewayInfoRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/1/devices/"
	{
		// Encode "deviceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "deviceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.DeviceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/lcg"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "DevicesGetLiveControlGatewayInfo", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDevicesGetLiveControlGatewayInfoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DevicesGetOtaUpdateHistory invokes Devices_GetOtaUpdateHistory operation.
//
// Gets the OTA update history for a device.
//
// GET /1/devices/{deviceId}/ota
func (c *Client) DevicesGetOtaUpdateHistory(ctx context.Context, params DevicesGetOtaUpdateHistoryParams) (DevicesGetOtaUpdateHistoryRes, error) {
	res, err := c.sendDevicesGetOtaUpdateHistory(ctx, params)
	return res, err
}

func (c *Client) sendDevicesGetOtaUpdateHistory(ctx context.Context, params DevicesGetOtaUpdateHistoryParams) (res DevicesGetOtaUpdateHistoryRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/1/devices/"
	{
		// Encode "deviceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "deviceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.DeviceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/ota"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "DevicesGetOtaUpdateHistory", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDevicesGetOtaUpdateHistoryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DevicesGetPairCode invokes Devices_GetPairCode operation.
//
// Get a pair code for a device.
//
// GET /1/devices/{deviceId}/pair
func (c *Client) DevicesGetPairCode(ctx context.Context, params DevicesGetPairCodeParams) (DevicesGetPairCodeRes, error) {
	res, err := c.sendDevicesGetPairCode(ctx, params)
	return res, err
}

func (c *Client) sendDevicesGetPairCode(ctx context.Context, params DevicesGetPairCodeParams) (res DevicesGetPairCodeRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/1/devices/"
	{
		// Encode "deviceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "deviceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.DeviceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/pair"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "DevicesGetPairCode", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDevicesGetPairCodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DevicesGetShockers invokes Devices_GetShockers operation.
//
// Get all shockers for a device.
//
// GET /1/devices/{deviceId}/shockers
func (c *Client) DevicesGetShockers(ctx context.Context, params DevicesGetShockersParams) (DevicesGetShockersRes, error) {
	res, err := c.sendDevicesGetShockers(ctx, params)
	return res, err
}

func (c *Client) sendDevicesGetShockers(ctx context.Context, params DevicesGetShockersParams) (res DevicesGetShockersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/1/devices/"
	{
		// Encode "deviceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "deviceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.DeviceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/shockers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "DevicesGetShockers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDevicesGetShockersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DevicesListDevices invokes Devices_ListDevices operation.
//
// Get all devices for the current user.
//
// GET /1/devices
func (c *Client) DevicesListDevices(ctx context.Context) (*ResponseDeviceIEnumerableBaseResponse, error) {
	res, err := c.sendDevicesListDevices(ctx)
	return res, err
}

func (c *Client) sendDevicesListDevices(ctx context.Context) (res *ResponseDeviceIEnumerableBaseResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/1/devices"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "DevicesListDevices", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDevicesListDevicesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DevicesRegenerateDeviceToken invokes Devices_RegenerateDeviceToken operation.
//
// Regenerate a device token.
//
// PUT /1/devices/{deviceId}
func (c *Client) DevicesRegenerateDeviceToken(ctx context.Context, params DevicesRegenerateDeviceTokenParams) (DevicesRegenerateDeviceTokenRes, error) {
	res, err := c.sendDevicesRegenerateDeviceToken(ctx, params)
	return res, err
}

func (c *Client) sendDevicesRegenerateDeviceToken(ctx context.Context, params DevicesRegenerateDeviceTokenParams) (res DevicesRegenerateDeviceTokenRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/1/devices/"
	{
		// Encode "deviceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "deviceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.DeviceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "DevicesRegenerateDeviceToken", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDevicesRegenerateDeviceTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DevicesRemoveDevice invokes Devices_RemoveDevice operation.
//
// Remove a device from current user's account.
//
// DELETE /1/devices/{deviceId}
func (c *Client) DevicesRemoveDevice(ctx context.Context, params DevicesRemoveDeviceParams) (DevicesRemoveDeviceRes, error) {
	res, err := c.sendDevicesRemoveDevice(ctx, params)
	return res, err
}

func (c *Client) sendDevicesRemoveDevice(ctx context.Context, params DevicesRemoveDeviceParams) (res DevicesRemoveDeviceRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/1/devices/"
	{
		// Encode "deviceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "deviceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.DeviceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "DevicesRemoveDevice", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDevicesRemoveDeviceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PublicGetOnlineDevicesStatistics invokes Public_GetOnlineDevicesStatistics operation.
//
// Gets online devices statistics.
//
// GET /1/public/stats
func (c *Client) PublicGetOnlineDevicesStatistics(ctx context.Context) (*StatsResponseBaseResponse, error) {
	res, err := c.sendPublicGetOnlineDevicesStatistics(ctx)
	return res, err
}

func (c *Client) sendPublicGetOnlineDevicesStatistics(ctx context.Context) (res *StatsResponseBaseResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/1/public/stats"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "PublicGetOnlineDevicesStatistics", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePublicGetOnlineDevicesStatisticsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PublicGetShareLink invokes Public_GetShareLink operation.
//
// Gets information about a public share link.
//
// GET /1/public/shares/links/{shareLinkId}
func (c *Client) PublicGetShareLink(ctx context.Context, params PublicGetShareLinkParams) (PublicGetShareLinkRes, error) {
	res, err := c.sendPublicGetShareLink(ctx, params)
	return res, err
}

func (c *Client) sendPublicGetShareLink(ctx context.Context, params PublicGetShareLinkParams) (res PublicGetShareLinkRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/1/public/shares/links/"
	{
		// Encode "shareLinkId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shareLinkId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ShareLinkId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "PublicGetShareLink", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePublicGetShareLinkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ShareLinksAddShocker invokes ShareLinks_AddShocker operation.
//
// Add a shocker to a share link.
//
// POST /1/shares/links/{shareLinkId}/{shockerId}
func (c *Client) ShareLinksAddShocker(ctx context.Context, params ShareLinksAddShockerParams) (ShareLinksAddShockerRes, error) {
	res, err := c.sendShareLinksAddShocker(ctx, params)
	return res, err
}

func (c *Client) sendShareLinksAddShocker(ctx context.Context, params ShareLinksAddShockerParams) (res ShareLinksAddShockerRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/1/shares/links/"
	{
		// Encode "shareLinkId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shareLinkId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ShareLinkId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "shockerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shockerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ShockerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "ShareLinksAddShocker", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeShareLinksAddShockerResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ShareLinksCreateShareLink invokes ShareLinks_CreateShareLink operation.
//
// Create a new share link.
//
// POST /1/shares/links
func (c *Client) ShareLinksCreateShareLink(ctx context.Context, request OptShareLinkCreate) (*GuidBaseResponse, error) {
	res, err := c.sendShareLinksCreateShareLink(ctx, request)
	return res, err
}

func (c *Client) sendShareLinksCreateShareLink(ctx context.Context, request OptShareLinkCreate) (res *GuidBaseResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/1/shares/links"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeShareLinksCreateShareLinkRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "ShareLinksCreateShareLink", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeShareLinksCreateShareLinkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ShareLinksDeleteShareLink invokes ShareLinks_DeleteShareLink operation.
//
// Deletes a share link.
//
// DELETE /1/shares/links/{shareLinkId}
func (c *Client) ShareLinksDeleteShareLink(ctx context.Context, params ShareLinksDeleteShareLinkParams) (ShareLinksDeleteShareLinkRes, error) {
	res, err := c.sendShareLinksDeleteShareLink(ctx, params)
	return res, err
}

func (c *Client) sendShareLinksDeleteShareLink(ctx context.Context, params ShareLinksDeleteShareLinkParams) (res ShareLinksDeleteShareLinkRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/1/shares/links/"
	{
		// Encode "shareLinkId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shareLinkId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ShareLinkId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "ShareLinksDeleteShareLink", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeShareLinksDeleteShareLinkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ShareLinksEditShocker invokes ShareLinks_EditShocker operation.
//
// Edit a shocker in a share link.
//
// PATCH /1/shares/links/{shareLinkId}/{shockerId}
func (c *Client) ShareLinksEditShocker(ctx context.Context, request OptShareLinkEditShocker, params ShareLinksEditShockerParams) (ShareLinksEditShockerRes, error) {
	res, err := c.sendShareLinksEditShocker(ctx, request, params)
	return res, err
}

func (c *Client) sendShareLinksEditShocker(ctx context.Context, request OptShareLinkEditShocker, params ShareLinksEditShockerParams) (res ShareLinksEditShockerRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/1/shares/links/"
	{
		// Encode "shareLinkId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shareLinkId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ShareLinkId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "shockerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shockerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ShockerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeShareLinksEditShockerRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "ShareLinksEditShocker", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeShareLinksEditShockerResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ShareLinksList invokes ShareLinks_List operation.
//
// Get all share links for the current user.
//
// GET /1/shares/links
func (c *Client) ShareLinksList(ctx context.Context) (*ShareLinkResponseIEnumerableBaseResponse, error) {
	res, err := c.sendShareLinksList(ctx)
	return res, err
}

func (c *Client) sendShareLinksList(ctx context.Context) (res *ShareLinkResponseIEnumerableBaseResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/1/shares/links"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "ShareLinksList", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeShareLinksListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ShareLinksPauseShocker invokes ShareLinks_PauseShocker operation.
//
// Pause a shocker in a share link.
//
// POST /1/shares/links/{shareLinkId}/{shockerId}/pause
func (c *Client) ShareLinksPauseShocker(ctx context.Context, request OptPauseRequest, params ShareLinksPauseShockerParams) (ShareLinksPauseShockerRes, error) {
	res, err := c.sendShareLinksPauseShocker(ctx, request, params)
	return res, err
}

func (c *Client) sendShareLinksPauseShocker(ctx context.Context, request OptPauseRequest, params ShareLinksPauseShockerParams) (res ShareLinksPauseShockerRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/1/shares/links/"
	{
		// Encode "shareLinkId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shareLinkId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ShareLinkId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "shockerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shockerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ShockerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pause"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeShareLinksPauseShockerRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "ShareLinksPauseShocker", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeShareLinksPauseShockerResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ShareLinksRemoveShocker invokes ShareLinks_RemoveShocker operation.
//
// Remove a shocker from a share link.
//
// DELETE /1/shares/links/{shareLinkId}/{shockerId}
func (c *Client) ShareLinksRemoveShocker(ctx context.Context, params ShareLinksRemoveShockerParams) (ShareLinksRemoveShockerRes, error) {
	res, err := c.sendShareLinksRemoveShocker(ctx, params)
	return res, err
}

func (c *Client) sendShareLinksRemoveShocker(ctx context.Context, params ShareLinksRemoveShockerParams) (res ShareLinksRemoveShockerRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/1/shares/links/"
	{
		// Encode "shareLinkId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shareLinkId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ShareLinkId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "shockerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shockerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ShockerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "ShareLinksRemoveShocker", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeShareLinksRemoveShockerResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SharesDeleteShareCode invokes Shares_DeleteShareCode operation.
//
// Delete a share code.
//
// DELETE /1/shares/code/{shareCodeId}
func (c *Client) SharesDeleteShareCode(ctx context.Context, params SharesDeleteShareCodeParams) (SharesDeleteShareCodeRes, error) {
	res, err := c.sendSharesDeleteShareCode(ctx, params)
	return res, err
}

func (c *Client) sendSharesDeleteShareCode(ctx context.Context, params SharesDeleteShareCodeParams) (res SharesDeleteShareCodeRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/1/shares/code/"
	{
		// Encode "shareCodeId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shareCodeId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ShareCodeId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "SharesDeleteShareCode", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSharesDeleteShareCodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SharesLinkShareCode invokes Shares_LinkShareCode operation.
//
// Link a share code to your account.
//
// POST /1/shares/code/{shareCodeId}
func (c *Client) SharesLinkShareCode(ctx context.Context, params SharesLinkShareCodeParams) (SharesLinkShareCodeRes, error) {
	res, err := c.sendSharesLinkShareCode(ctx, params)
	return res, err
}

func (c *Client) sendSharesLinkShareCode(ctx context.Context, params SharesLinkShareCodeParams) (res SharesLinkShareCodeRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/1/shares/code/"
	{
		// Encode "shareCodeId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shareCodeId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ShareCodeId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "SharesLinkShareCode", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSharesLinkShareCodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ShockerEditShocker invokes Shocker_EditShocker operation.
//
// Edit a shocker.
//
// PATCH /1/shockers/{shockerId}
func (c *Client) ShockerEditShocker(ctx context.Context, request OptNewShocker, params ShockerEditShockerParams) (ShockerEditShockerRes, error) {
	res, err := c.sendShockerEditShocker(ctx, request, params)
	return res, err
}

func (c *Client) sendShockerEditShocker(ctx context.Context, request OptNewShocker, params ShockerEditShockerParams) (res ShockerEditShockerRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/1/shockers/"
	{
		// Encode "shockerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shockerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ShockerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeShockerEditShockerRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "ShockerEditShocker", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeShockerEditShockerResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ShockerGetShockerById invokes Shocker_GetShockerById operation.
//
// Get information about a shocker.
//
// GET /1/shockers/{shockerId}
func (c *Client) ShockerGetShockerById(ctx context.Context, params ShockerGetShockerByIdParams) (ShockerGetShockerByIdRes, error) {
	res, err := c.sendShockerGetShockerById(ctx, params)
	return res, err
}

func (c *Client) sendShockerGetShockerById(ctx context.Context, params ShockerGetShockerByIdParams) (res ShockerGetShockerByIdRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/1/shockers/"
	{
		// Encode "shockerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shockerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ShockerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "ShockerGetShockerById", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeShockerGetShockerByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ShockerGetShockerLogs invokes Shocker_GetShockerLogs operation.
//
// Get the logs for a shocker.
//
// GET /1/shockers/{shockerId}/logs
func (c *Client) ShockerGetShockerLogs(ctx context.Context, params ShockerGetShockerLogsParams) (ShockerGetShockerLogsRes, error) {
	res, err := c.sendShockerGetShockerLogs(ctx, params)
	return res, err
}

func (c *Client) sendShockerGetShockerLogs(ctx context.Context, params ShockerGetShockerLogsParams) (res ShockerGetShockerLogsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/1/shockers/"
	{
		// Encode "shockerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shockerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ShockerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/logs"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "ShockerGetShockerLogs", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeShockerGetShockerLogsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ShockerGetShockerShares invokes Shocker_GetShockerShares operation.
//
// Get all shares for a shocker.
//
// GET /1/shockers/{shockerId}/shares
func (c *Client) ShockerGetShockerShares(ctx context.Context, params ShockerGetShockerSharesParams) (ShockerGetShockerSharesRes, error) {
	res, err := c.sendShockerGetShockerShares(ctx, params)
	return res, err
}

func (c *Client) sendShockerGetShockerShares(ctx context.Context, params ShockerGetShockerSharesParams) (res ShockerGetShockerSharesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/1/shockers/"
	{
		// Encode "shockerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shockerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ShockerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/shares"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "ShockerGetShockerShares", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeShockerGetShockerSharesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ShockerListSharedShockers invokes Shocker_ListSharedShockers operation.
//
// List all shockers shared with the authenticated user.
//
// GET /1/shockers/shared
func (c *Client) ShockerListSharedShockers(ctx context.Context) (*OwnerShockerResponseIEnumerableIEnumerableBaseResponse, error) {
	res, err := c.sendShockerListSharedShockers(ctx)
	return res, err
}

func (c *Client) sendShockerListSharedShockers(ctx context.Context) (res *OwnerShockerResponseIEnumerableIEnumerableBaseResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/1/shockers/shared"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "ShockerListSharedShockers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeShockerListSharedShockersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ShockerListShockers invokes Shocker_ListShockers operation.
//
// List all shockers belonging to the authenticated user.
//
// GET /1/shockers/own
func (c *Client) ShockerListShockers(ctx context.Context) (*ResponseDeviceWithShockersIEnumerableBaseResponse, error) {
	res, err := c.sendShockerListShockers(ctx)
	return res, err
}

func (c *Client) sendShockerListShockers(ctx context.Context) (res *ResponseDeviceWithShockersIEnumerableBaseResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/1/shockers/own"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "ShockerListShockers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeShockerListShockersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ShockerPauseShocker invokes Shocker_PauseShocker operation.
//
// Pause or unpause a shocker.
//
// POST /1/shockers/{shockerId}/pause
func (c *Client) ShockerPauseShocker(ctx context.Context, request OptPauseRequest, params ShockerPauseShockerParams) (ShockerPauseShockerRes, error) {
	res, err := c.sendShockerPauseShocker(ctx, request, params)
	return res, err
}

func (c *Client) sendShockerPauseShocker(ctx context.Context, request OptPauseRequest, params ShockerPauseShockerParams) (res ShockerPauseShockerRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/1/shockers/"
	{
		// Encode "shockerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shockerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ShockerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/pause"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeShockerPauseShockerRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "ShockerPauseShocker", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeShockerPauseShockerResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ShockerRegisterShocker invokes Shocker_RegisterShocker operation.
//
// Register a shocker.
//
// POST /1/shockers
func (c *Client) ShockerRegisterShocker(ctx context.Context, request OptNewShocker) (ShockerRegisterShockerRes, error) {
	res, err := c.sendShockerRegisterShocker(ctx, request)
	return res, err
}

func (c *Client) sendShockerRegisterShocker(ctx context.Context, request OptNewShocker) (res ShockerRegisterShockerRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/1/shockers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeShockerRegisterShockerRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "ShockerRegisterShocker", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeShockerRegisterShockerResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ShockerRemoveShocker invokes Shocker_RemoveShocker operation.
//
// Remove a shocker.
//
// DELETE /1/shockers/{shockerId}
func (c *Client) ShockerRemoveShocker(ctx context.Context, params ShockerRemoveShockerParams) (ShockerRemoveShockerRes, error) {
	res, err := c.sendShockerRemoveShocker(ctx, params)
	return res, err
}

func (c *Client) sendShockerRemoveShocker(ctx context.Context, params ShockerRemoveShockerParams) (res ShockerRemoveShockerRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/1/shockers/"
	{
		// Encode "shockerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shockerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ShockerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "ShockerRemoveShocker", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeShockerRemoveShockerResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ShockerSendControl invokes Shocker_SendControl operation.
//
// Send a control message to shockers.
//
// POST /2/shockers/control
func (c *Client) ShockerSendControl(ctx context.Context, request OptControlRequest) (ShockerSendControlRes, error) {
	res, err := c.sendShockerSendControl(ctx, request)
	return res, err
}

func (c *Client) sendShockerSendControl(ctx context.Context, request OptControlRequest) (res ShockerSendControlRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/2/shockers/control"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeShockerSendControlRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "ShockerSendControl", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeShockerSendControlResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ShockerSendControlDEPRECATED invokes Shocker_SendControl_DEPRECATED operation.
//
// Send a control message to shockers (Deprecated in favor of the /2/shockers/control endpoint).
//
// POST /1/shockers/control
func (c *Client) ShockerSendControlDEPRECATED(ctx context.Context, request []Control) (ShockerSendControlDEPRECATEDRes, error) {
	res, err := c.sendShockerSendControlDEPRECATED(ctx, request)
	return res, err
}

func (c *Client) sendShockerSendControlDEPRECATED(ctx context.Context, request []Control) (res ShockerSendControlDEPRECATEDRes, err error) {
	// Validate request before sending.
	if err := func() error {
		var failures []validate.FieldError
		for i, elem := range request {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/1/shockers/control"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeShockerSendControlDEPRECATEDRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "ShockerSendControlDEPRECATED", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeShockerSendControlDEPRECATEDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ShockerShockerShareCodeCreate invokes Shocker_ShockerShareCodeCreate operation.
//
// Create a share code for a shocker.
//
// POST /1/shockers/{shockerId}/shares
func (c *Client) ShockerShockerShareCodeCreate(ctx context.Context, request OptCreateShareCode, params ShockerShockerShareCodeCreateParams) (ShockerShockerShareCodeCreateRes, error) {
	res, err := c.sendShockerShockerShareCodeCreate(ctx, request, params)
	return res, err
}

func (c *Client) sendShockerShockerShareCodeCreate(ctx context.Context, request OptCreateShareCode, params ShockerShockerShareCodeCreateParams) (res ShockerShockerShareCodeCreateRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/1/shockers/"
	{
		// Encode "shockerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shockerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ShockerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/shares"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeShockerShockerShareCodeCreateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "ShockerShockerShareCodeCreate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeShockerShockerShareCodeCreateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ShockerShockerShareCodeList invokes Shocker_ShockerShareCodeList operation.
//
// List all share codes for a shocker.
//
// GET /1/shockers/{shockerId}/shareCodes
func (c *Client) ShockerShockerShareCodeList(ctx context.Context, params ShockerShockerShareCodeListParams) (ShockerShockerShareCodeListRes, error) {
	res, err := c.sendShockerShockerShareCodeList(ctx, params)
	return res, err
}

func (c *Client) sendShockerShockerShareCodeList(ctx context.Context, params ShockerShockerShareCodeListParams) (res ShockerShockerShareCodeListRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/1/shockers/"
	{
		// Encode "shockerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shockerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ShockerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/shareCodes"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "ShockerShockerShareCodeList", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeShockerShockerShareCodeListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ShockerShockerShareCodePause invokes Shocker_ShockerShareCodePause operation.
//
// Pause/Unpause a share code for a shocker.
//
// POST /1/shockers/{shockerId}/shares/{sharedWithUserId}/pause
func (c *Client) ShockerShockerShareCodePause(ctx context.Context, request OptPauseRequest, params ShockerShockerShareCodePauseParams) (ShockerShockerShareCodePauseRes, error) {
	res, err := c.sendShockerShockerShareCodePause(ctx, request, params)
	return res, err
}

func (c *Client) sendShockerShockerShareCodePause(ctx context.Context, request OptPauseRequest, params ShockerShockerShareCodePauseParams) (res ShockerShockerShareCodePauseRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/1/shockers/"
	{
		// Encode "shockerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shockerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ShockerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/shares/"
	{
		// Encode "sharedWithUserId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sharedWithUserId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.SharedWithUserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/pause"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeShockerShockerShareCodePauseRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "ShockerShockerShareCodePause", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeShockerShockerShareCodePauseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ShockerShockerShareCodeRemove invokes Shocker_ShockerShareCodeRemove operation.
//
// Remove a share code for a shocker.
//
// DELETE /1/shockers/{shockerId}/shares/{sharedWithUserId}
func (c *Client) ShockerShockerShareCodeRemove(ctx context.Context, params ShockerShockerShareCodeRemoveParams) (ShockerShockerShareCodeRemoveRes, error) {
	res, err := c.sendShockerShockerShareCodeRemove(ctx, params)
	return res, err
}

func (c *Client) sendShockerShockerShareCodeRemove(ctx context.Context, params ShockerShockerShareCodeRemoveParams) (res ShockerShockerShareCodeRemoveRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/1/shockers/"
	{
		// Encode "shockerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shockerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ShockerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/shares/"
	{
		// Encode "sharedWithUserId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sharedWithUserId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.SharedWithUserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "ShockerShockerShareCodeRemove", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeShockerShockerShareCodeRemoveResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ShockerShockerShareCodeUpdate invokes Shocker_ShockerShareCodeUpdate operation.
//
// Update a share code for a shocker.
//
// PATCH /1/shockers/{shockerId}/shares/{sharedWithUserId}
func (c *Client) ShockerShockerShareCodeUpdate(ctx context.Context, request OptCreateShareCode, params ShockerShockerShareCodeUpdateParams) (ShockerShockerShareCodeUpdateRes, error) {
	res, err := c.sendShockerShockerShareCodeUpdate(ctx, request, params)
	return res, err
}

func (c *Client) sendShockerShockerShareCodeUpdate(ctx context.Context, request OptCreateShareCode, params ShockerShockerShareCodeUpdateParams) (res ShockerShockerShareCodeUpdateRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/1/shockers/"
	{
		// Encode "shockerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shockerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ShockerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/shares/"
	{
		// Encode "sharedWithUserId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sharedWithUserId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.SharedWithUserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeShockerShockerShareCodeUpdateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "ShockerShockerShareCodeUpdate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeShockerShockerShareCodeUpdateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TokensCreateToken invokes Tokens_CreateToken operation.
//
// Create a new token.
//
// POST /1/tokens
func (c *Client) TokensCreateToken(ctx context.Context, request OptCreateTokenRequest) (*StringBaseResponse, error) {
	res, err := c.sendTokensCreateToken(ctx, request)
	return res, err
}

func (c *Client) sendTokensCreateToken(ctx context.Context, request OptCreateTokenRequest) (res *StringBaseResponse, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/1/tokens"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTokensCreateTokenRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "TokensCreateToken", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTokensCreateTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TokensDeleteToken invokes Tokens_DeleteToken operation.
//
// Revoke a token from the current user.
//
// DELETE /1/tokens/{tokenId}
func (c *Client) TokensDeleteToken(ctx context.Context, params TokensDeleteTokenParams) (TokensDeleteTokenRes, error) {
	res, err := c.sendTokensDeleteToken(ctx, params)
	return res, err
}

func (c *Client) sendTokensDeleteToken(ctx context.Context, params TokensDeleteTokenParams) (res TokensDeleteTokenRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/1/tokens/"
	{
		// Encode "tokenId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tokenId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.TokenId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "TokensDeleteToken", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTokensDeleteTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TokensEditToken invokes Tokens_EditToken operation.
//
// Edit a token.
//
// PATCH /1/tokens/{tokenId}
func (c *Client) TokensEditToken(ctx context.Context, request OptEditTokenRequest, params TokensEditTokenParams) (TokensEditTokenRes, error) {
	res, err := c.sendTokensEditToken(ctx, request, params)
	return res, err
}

func (c *Client) sendTokensEditToken(ctx context.Context, request OptEditTokenRequest, params TokensEditTokenParams) (res TokensEditTokenRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/1/tokens/"
	{
		// Encode "tokenId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tokenId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.TokenId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTokensEditTokenRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "TokensEditToken", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTokensEditTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TokensGetTokenById invokes Tokens_GetTokenById operation.
//
// Get a token by id.
//
// GET /1/tokens/{tokenId}
func (c *Client) TokensGetTokenById(ctx context.Context, params TokensGetTokenByIdParams) (TokensGetTokenByIdRes, error) {
	res, err := c.sendTokensGetTokenById(ctx, params)
	return res, err
}

func (c *Client) sendTokensGetTokenById(ctx context.Context, params TokensGetTokenByIdParams) (res TokensGetTokenByIdRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/1/tokens/"
	{
		// Encode "tokenId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tokenId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.TokenId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "TokensGetTokenById", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTokensGetTokenByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TokensListTokens invokes Tokens_ListTokens operation.
//
// List all tokens for the current user.
//
// GET /1/tokens
func (c *Client) TokensListTokens(ctx context.Context) (*TokenResponseIEnumerableBaseResponse, error) {
	res, err := c.sendTokensListTokens(ctx)
	return res, err
}

func (c *Client) sendTokensListTokens(ctx context.Context) (res *TokenResponseIEnumerableBaseResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/1/tokens"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "TokensListTokens", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTokensListTokensResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersGetSelf invokes Users_GetSelf operation.
//
// Get the current user's information.
//
// GET /1/users/self
func (c *Client) UsersGetSelf(ctx context.Context) (*SelfResponseBaseResponse, error) {
	res, err := c.sendUsersGetSelf(ctx)
	return res, err
}

func (c *Client) sendUsersGetSelf(ctx context.Context) (res *SelfResponseBaseResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/1/users/self"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "UsersGetSelf", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUsersGetSelfResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// VersionGetBackendVersion invokes Version_GetBackendVersion operation.
//
// Gets the version of the OpenShock backend.
//
// GET /1
func (c *Client) VersionGetBackendVersion(ctx context.Context) (*RootResponseBaseResponse, error) {
	res, err := c.sendVersionGetBackendVersion(ctx)
	return res, err
}

func (c *Client) sendVersionGetBackendVersion(ctx context.Context) (res *RootResponseBaseResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/1"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOpenShockToken(ctx, "VersionGetBackendVersion", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OpenShockToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeVersionGetBackendVersionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
